# Java面试题回顾

## Java基础部分

问:一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？
答:可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。

问:char型变量中能不能存贮一个中文汉字?为什么?
答:char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，
所以，char型变量中当然可以存储汉字

问:使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？
答:使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。

问:"=="和equals方法究竟有什么区别？
答:==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，
要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。
equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的

静态变量和实例变量的区别？

问:在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。
答:在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，
其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，
而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，
静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后
才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

问:构造器Constructor是否可被override?
答:构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。

问:面向对象的特征有哪些方面
答:
封装:封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响
抽象:抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处。(属性,方法)
继承:继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性
多态:多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定

问:volatile 类型变量提供什么保证？
答:volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。

问:64 位 JVM 中，int 的长度是多数？
答:Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的

问:a==b”和”a.equals(b)”有什么区别？
答:如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。

问:有没有可能两个不相等的对象有有相同的 hashcode？
答:有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。

说出几点 Java 中使用 Collections 的最佳实践(答案)
这是我在使用 Java 中 Collectionc 类的一些最佳实践：
a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。
b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。
c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。
d）使用迭代器来循环集合。
e）使用集合的时候使用泛型。

## 设计模式相关

依赖注入和工程模式之间有什么不同？(答案)
虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。

适配器模式和装饰器模式有什么区别？(答案)
虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。

适配器模式和代理模式之前有什么不同？(答案)
这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。

什么是模板方法模式？(答案)
模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。

### Spring相关

Spring的优点?

- 1.轻量级
- 2.IOC控制反转,通过依赖注入对象,实现松耦合
- 3.AOP面向切面编程:把应用的业务逻辑与系统的服务分离开来
- 4.容器:Spring包含并管理应用程序对象的配置及生命周期
- 5.MVC框架:设计优良的web框架
- 6.事务管理:
- 7.异常处理:

Spring的IOC容器是什么?
负责创建对象,管理对象(依赖注入),整合对象,配置对象以及管理这些对象的生命周期

Spring的依赖注入DI又是什么?
依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。

Spring中支持的bean作用域?
Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：
singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。
prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。
request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。
Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。
global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。
全局作用域与Servlet中的session作用域效果相同。

核心容器(应用上下文)模块是什么?
这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。

Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：

    代理模式—在AOP和remoting中被用的比较多。
    单例模式—在spring配置文件中定义的bean默认为单例模式。
    模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
    前端控制器—Spring提供了DispatcherServlet来对请求进行分发。
    视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。
    依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。
    工厂模式—BeanFactory用来创建对象的实例。

Spring支持的事务管理类型有哪些?
Spring支持如下两种方式的事务管理：
编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。
声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。

AOP的概念:

    AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

    AOP技术恰恰相反，它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

    使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

AOP核心概念?

    1、横切关注点
    对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点
    2、切面（aspect）
    类是对物体特征的抽象，切面就是对横切关注点的抽象
    3、连接点（joinpoint）
    被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器
    4、切入点（pointcut）
    对连接点进行拦截的定义
    5、通知（advice）
    所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类
    6、目标对象
    代理的目标对象
    7、织入（weave）
    将切面应用到目标对象并导致代理对象创建的过程
    8、引入（introduction）
    在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段

Spring对AOP的支持

    Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：

    1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了

    2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB

    AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：

    1、定义普通业务组件

    2、定义切入点，一个切入点可能横切多个业务组件

    3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作

    所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法=增强处理+被代理对象的方法。

Spring的事务传播属性和级别:

    第一个是REQUIRED，这个也是spring默认的事务传播的默认属性，他表示如果在有transaction的情况下执行，如果没有，则创建新的transaction

    第二个是SUPPORTS,表示如果当前有transaction，在transaction情况下执行，如果没有，那么在没有transaction情况下执行，

    第三个是MANDATORY，英文表示强制的，他表示必须在有transaction的情况下执行，如果当前没有transaction，他会直接抛出异常Ille

    第四个是REQUIRES_NEW，他表示需要在新的transaction情况下执行，如果以前有，那么将会把它挂起

    第五个是NOT_SUPPORTED，表示如果当前没有transaction执行，负责会挂起当前transaction后在执行，

    第六个是NEVER，表示必须在没有transation的情况下执行，如果有transaction，则会抛出IllegalTransactionStateException异常。

    第七个是NESTED，表示如果当前有一个活动的事务，那么他会嵌套在当前事务中，如果没有，那么他的将会属性值设置为REQUIRED

事务传播级别：

    第一个是ISOLATION_DEFAULT，这个是PlatfromTransactionManager默认的级别，也是使用数据库默认的隔离级别，其余四个和数据库的隔离级别是相对应的

    第二个是ISOLATION_READ_UNCOMMITTED，这个是事务隔离的最低级别，他允许其他事务看到看到这个事务未提交的数据，它对应的数据库的事务隔离级别就是READ_UNCOMMITED，由于是读取其他事务未提交的数据，也被称为脏读，

    第三个是ISOLATION_READ_COMMITED，保证一个事务修改的数据提交后才能被其他事务看到，另外一个事务也不能读取该事务为提交的数据，它对应这数据的READ_COMMITED级别，这个是大多数数据库默认的隔离级别，但不是mysql的默认级别，

    第四个是ISOLATION_REPEATABLE_READ,这种级别的事务隔离，可以防止脏读，不可重复读，但是不能阻挡幻想读，它对应着数据库的隔离级别是REPEATABLE_ABLE，这个是mysql默认的数据库隔离级别，他保证了一个事务在多个实例并发读取数据的时候看到数据是一致的，但是还有一个棘手的问题，就是幻想读，因为他无法避免一种情况，就是在某个事务读取一个范围内的数据行的时候，别的事务有可能在这个范围内插入了新的数据行，这就造成了幻想读，不过InnoDB和Falcon存储引擎通过多版本并发机制解决了这个问题，

    第五个是ISOLATION_SERIALIZABLE ，花费最高代价最可靠的隔离级别，事务被处理为顺序执行，可以避免脏读，不可重复读和幻想读，他对应的数据库的事务隔离级别是Serializable

Struts2面试题

为什么要使用Struts2

    Struts2 是一个相当强大的Java Web开源框架，是一个基于POJO的Action的MVC Web框架。它基于当年的Webwork和XWork框架，继承其优点，同时做了相当的改进。
    1.Struts2基于MVC架构，框架结构清晰，开发流程一目了然，开发人员可以很好的掌控开发的过程。
    2使用OGNL进行参数传递。
    OGNL提供了在Struts2里访问各种作用域中的数据的简单方式，你可以方便的获取Request，Attribute，Application，Session，Parameters中的数据。大大简化了开发人员在获取这些数据时的代码量。
    3强大的拦截器
    Struts2 的拦截器是一个Action级别的AOP，Struts2中的许多特性都是通过拦截器来实现的，例如异常处理，文件上传，验证等。拦截器是可配置与重用的，可以将一些通用的功能如：登录验证，权限验证等置于拦截器中以完成一些Java Web项目中比较通用的功能。在我实现的的一Web项目中，就是使用Struts2的拦截器来完成了系统中的权限验证功能。
    4易于测试
    Struts2的Action都是简单的POJO，这样可以方便的对Struts2的Action编写测试用例，大大方便了5Java Web项目的测试。
    易于扩展的插件机制在Struts2添加扩展是一件愉快而轻松的事情，只需要将所需要的Jar包放到WEB-INF/lib文件夹中，在struts.xml中作一些简单的设置就可以实现扩展。
    6模块化管理
    Struts2已经把模块化作为了体系架构中的基本思想，可以通过三种方法来将应用程序模块化：将配置信息拆分成多个文件把自包含的应用模块创建为插件创建新的框架特性，即将与特定应用无关的新功能组织成插件，以添加到多个应用中去。
    7全局结果与声明式异常
    为应用程序添加全局的Result，和在配置文件中对异常进行处理，这样当处理过程中出现指定异常时，可以跳转到特定页面。