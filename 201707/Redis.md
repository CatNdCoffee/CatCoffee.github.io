# Redis概览

## Redis简介

关键词:开源免费,高性能

redis与其他key-value缓存产品有以下特点:

- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用
- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储
- Redis支持数据的备份，即master-slave模式的数据备份

## 五种数据类型

- Stirng:
- hash:Redis hash是一个String类型的filed和value的映射表,特别适合用于存储对象
- list:简单的字符串列表,将按照插入顺序排序
- set:无序集合,不允许出现重复数据
- sorted set:Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复

## 常用方法

INCR:值原子性增长.INCR 命令将字符串值解析为整数，并增加一，最后赋值后作为新值。还有一些类似的命令 INCRBY，DECR 和 DECRBY。它们以略微不同的方式执行，但其内部都是一样的命令。

    为什么说 INCR 命令是原子的？因为即使多个 客户端对同一个键发送 INCR 命令也不会造成竞争条件 (race condition)。例如，一定不会发生客户端 1 和客户端 2 同时读到”10”，都增加到 11，然后设置新值为 11。最后的结果将会一直是 12，读 - 增加 - 写操作在执行时，其他客户端此时不会执行相关命令。

MSET/MGET:一次设置或检索多个键(有利于减少延迟)

EXIST:返回1/0,表示键在数据库中是否存在

DEL:删除

EXPIRE:给键设置超时，也就是一个有限的生存时间。当生存时间到了，键就会自动被销毁，就像用户调用 DEL 命令一样。(ex:expire key _timeValue_)

快速过一下 Redis 过期的信息：

- 过期时间可以设置为秒或者毫秒精度。
- 过期时间分辨率总是 1 毫秒。
- 过期信息被复制和持久化到磁盘，当 Redis 停止时时间仍然在计算 (也就是说 Redis 保存了过期时间)。

TTL:检查键的生存剩余时间

## List类型详解

特点:

- Redis的List是由链表实现的,插入数据快,但查询速度慢
- LPUSH/RPUSH
- 能在常数时间内获得常数长度
- LRANGE:从列表中提取一个范围内的元素.LRANGE 命令使用两个索引下标，分别是返回的范围的开始和结束元素。两个索引坐标可以是负数，表示从后往前数，所以 - 1 表示最后一个元素，-2 表示倒数第二个元素，等等(ex: lrange mylist 0 -1,负数表示从后往前数)
- RPOP:弹出操作.弹出元素指的是从列表中检索元素，并同时将其从列表中清除的操作。你可以从左边或者右边弹出元素，类似于你可以从列表的两端添加元素。
- 上限列表Capped:使用LTRIM命令来使redis仅仅记住最新的N项,丢弃掉所有老项.

## Hash类型详解

- HSET/HGET/HMSET/HMGET

## Set类型详解

- SAAD:添加
- SPOP:随机抽取一个元素,同时从set中删除

## 其他功能

- 发布订阅
- 事务
- 脚本

高级功能:

- 数据备份与恢复
- 安全:配置密码验证

## 集中缓存算法

FIFO:先进先出算法
LFU:Least Frequently Used,最近最少使用算法,及"如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小"
_LRU_:Least Recently Used,最近最久未使用.及"如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小"

一种LRU实现方式:　利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。

## 分片partioning

分片(partitioning)就是将你的数据拆分到多个 Redis 实例的过程，这样每个实例将只包含所有键的子集。本文第一部分将向你介绍分片的概念，第二部分将向你展示 Redis 分片的可选方案

**为何使用分片?**Redis 的分片承担着两个主要目标：

- 1.允许使用很多电脑的内存总和来支持更大的数据库。没有分片，你就被局限于单机能支持的内存容量。
- 2.允许伸缩计算能力到多核或多服务器，伸缩网络带宽到多服务器或多网络适配器。

## 复制(主从redis服务器)

Redis 的复制 (replication) 是一种使用和配置起来非常简单的主从(master-slave)复制，允许 Redis 从服务器成为主服务器的精确副本

## 持久化

Redis 提供了不同持久化范围的选项：

- RDB 持久化以指定的时间间隔执行数据集的即时点(point-in-time)快照
- AOF 持久化在服务端记录每次收到的写操作，在服务器启动时会重放，以重建原始数据集。命令使用和 Redis 协议一样的格式以追加的方式来记录。当文件太大时 Redis 会在后台重写日志

如果你愿意，你可以完全禁止持久化，如果你只是希望你的数据在服务器运行期间才存在的话
可以在同一个实例上同时支持 AOF 和 RDB。注意，在这种情况下，当 Redis 重启时，AOF 文件会被用于重建原始数据集，因为它被保证是最完整的数据

### RDB优点

- RDB 是一种表示某个即时点的 Redis 数据的紧凑文件RDB 文件适合用于备份。例如，你可能想要每小时归档最近 24 小时的 RDB 文件，每天保存近 30 天的 RDB 快照。这允许你很容易的恢复不同版本的数据集以容灾。
- RDB 非常适合于灾难恢复，作为一个紧凑的单一文件，可以被传输到远程的数据中心，或者是 Amazon S3(可能得加密)
- RDB 最大化了 Redis 的性能，因为 Redis 父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘 IO 这样的操作
- RDB 在重启保存了大数据集的实例时比 AOF 要快

### RDB缺点

当需要在 Redis 停止工作(例如停电)时最小化数据丢失，RDB 可能不太好。你可以配置不同的保存点(save point)来保存 RDB 文件(例如，至少 5 分钟和对数据集 100 次写之后，但是你可以有多个保存点)。然而，你通常每隔 5 分钟或更久创建一个 RDB 快照，所以一旦 Redis 因为任何原因没有正确关闭而停止工作，你就得做好最近几分钟数据丢失的准备了。
RDB 需要经常调用 fork()子进程来持久化到磁盘。如果数据集很大的话，fork()比较耗时，结果就是，当数据集非常大并且 CPU 性能不够强大的话，Redis 会停止服务客户端几毫秒甚至一秒。AOF 也需要 fork()，但是你可以调整多久频率重写日志而不会有损(trade-off)持久性(durability)。

### AOF优点

- 使用 AOF Redis 会更具有可持久性(durable)：你可以有很多不同的 fsync 策略：没有 fsync，每秒 fsync，每次请求时 fsync。使用默认的每秒 fsync 策略，写性能也仍然很不错(fsync 是由后台线程完成的，主线程继续努力地执行写请求)，即便你也就仅仅只损失一秒钟的写数据。
- AOF 日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof 工具也可以很轻易的修复。
- 当 AOF 文件变得很大时，Redis 会自动在后台进行重写。重写是绝对安全的，因为 Redis 继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis 就会切换这两个文件，并开始往新文件追加。
- AOF 文件里面包含一个接一个的操作，以易于理解和解析的格式存储。你也可以轻易的导出一个 AOF 文件。例如，即使你不小心错误地使用 FLUSHALL 命令清空一切，如果此时并没有执行重写，你仍然可以保存你的数据集，你只要停止服务器，删除最后一条命令，然后重启 Redis 就可以。

### AOF缺点

对同样的数据集，AOF 文件通常要大于等价的 RDB 文件。
AOF 可能比 RDB 慢，这取决于准确的 fsync 策略。通常 fsync 设置为每秒一次的话性能仍然很高，如果关闭 fsync，即使在很高的负载下也和 RDB 一样的快。不过，即使在很大的写负载情况下，RDB 还是能提供能好的最大延迟保证。

### How to choose

通常来说，你应该同时使用这两种持久化方法，以达到和 PostgreSQL 提供的一样的数据安全程度。

如果你很关注你的数据，但是仍然可以接受灾难时有几分钟的数据丢失，你可以只单独使用 RDB。

有很多用户单独使用 AOF，但是我们并不鼓励这样，因为时常进行 RDB 快照非常方便于数据库备份，启动速度也较之快，还避免了 AOF 引擎的 bug。

## Redis集群

### Redis集群的数据分片(sharding)

哈希槽hashSlot:Redis 集群有 _16384_ 个哈希槽，我们只是使用键的 CRC16 编码对 16384 取模来计算一个指定键所属的哈希槽。
当往Redis Cluster中加入一个Key时，会根据crc16(key) mod 16384计算这个key应该分布到哪个hash slot中，一个hash slot中会有很多key和value。可以理解成表的分区，使用单节点时的redis时只有一个表，所有的key都放在这个表里；改用Redis Cluster以后会自动为你生成16384个分区表，insert数据时会根据上面的简单算法来决定key应该存在哪个分区，每个分区里有很多key。

主从模型master-slave:保证高可用性

注意，**可以正常运转的最小集群需要包含至少 3 个主服务器节点。在你的第一次尝试中，强烈建议开始一个 6 个节点的集群，3 个主服务器，3 个从服务器**